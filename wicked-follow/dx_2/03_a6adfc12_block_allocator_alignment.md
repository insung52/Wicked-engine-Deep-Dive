# 커밋 #3: a6adfc12 - Block allocator should respect alignment of items

## 기본 정보

| 항목 | 내용 |
|------|------|
| 커밋 해시 | `a6adfc12` |
| 날짜 | 2025-11-02 |
| 작성자 | Turánszki János |
| 카테고리 | 버그수정 / 안정성 |
| 우선순위 | 중간 |

## 변경 파일 요약

| 파일 | 변경 |
|------|------|
| wiAllocator.h | `BlockAllocator`에서 아이템 정렬(alignment) 보장 |

---

## 배경 지식: 메모리 정렬 (Memory Alignment)

### 정렬이란?

**메모리 정렬(alignment)**은 데이터가 메모리의 특정 배수 주소에 위치해야 함을 의미합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    메모리 주소와 정렬                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  메모리 주소:  0   1   2   3   4   5   6   7   8   9  10  11    │
│              ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐ │
│              │   │   │   │   │   │   │   │   │   │   │   │   │ │
│              └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘ │
│                                                                 │
│  4바이트 정렬 (alignof(int) = 4):                               │
│  - 주소 0: ✓ 정렬됨 (0 % 4 == 0)                               │
│  - 주소 4: ✓ 정렬됨 (4 % 4 == 0)                               │
│  - 주소 8: ✓ 정렬됨 (8 % 4 == 0)                               │
│  - 주소 1: ✗ 미정렬 (1 % 4 != 0)                               │
│  - 주소 3: ✗ 미정렬 (3 % 4 != 0)                               │
│                                                                 │
│  8바이트 정렬 (alignof(double) = 8):                            │
│  - 주소 0: ✓ 정렬됨 (0 % 8 == 0)                               │
│  - 주소 8: ✓ 정렬됨 (8 % 8 == 0)                               │
│  - 주소 4: ✗ 미정렬 (4 % 8 != 0)                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 왜 정렬이 중요한가?

#### 1. 성능 (Performance)

```
┌─────────────────────────────────────────────────────────────────┐
│              정렬된 접근 vs 미정렬 접근                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  정렬된 접근 (주소 0에 4바이트 int):                            │
│  ┌───┬───┬───┬───┐                                              │
│  │ B0│ B1│ B2│ B3│  → 단일 메모리 읽기                          │
│  └───┴───┴───┴───┘                                              │
│   0   1   2   3                                                 │
│                                                                 │
│  미정렬 접근 (주소 1에 4바이트 int):                            │
│      ┌───┬───┬───┬───┐                                          │
│  │   │ B0│ B1│ B2│ B3│                                          │
│  └───┴───┴───┴───┴───┘                                          │
│   0   1   2   3   4                                             │
│                                                                 │
│  → 두 번의 메모리 읽기 + 조합 필요                              │
│  → 성능 저하 (2배 이상 느릴 수 있음)                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 2. 정확성 (Correctness)

일부 CPU 아키텍처에서는 미정렬 접근이 **하드웨어 예외**를 발생시킵니다:
- ARM (일부 모드)
- SPARC
- MIPS (일부)

x86/x64는 미정렬 접근을 허용하지만 성능 페널티 존재.

#### 3. SIMD 연산

```cpp
// SSE/AVX 연산은 16/32바이트 정렬 필요
__m128 simd_data;  // alignof(__m128) = 16

// 미정렬 주소에서 SIMD 로드 시:
// - _mm_load_ps(): 크래시!
// - _mm_loadu_ps(): 동작하지만 느림
```

#### 4. 원자적 연산 (Atomic Operations)

```cpp
std::atomic<uint64_t> counter;  // alignof = 8 필요

// 미정렬된 atomic 변수:
// - 원자성 보장 안 됨 (lock 필요)
// - 또는 크래시
```

---

## 배경 지식: C++ alignof와 alignas

### alignof 연산자

타입의 정렬 요구사항을 바이트 단위로 반환합니다.

```cpp
// 기본 타입
alignof(char)   = 1
alignof(short)  = 2
alignof(int)    = 4
alignof(double) = 8
alignof(void*)  = 8  (64비트 시스템)

// 구조체는 가장 큰 멤버의 정렬을 따름
struct Example {
    char a;    // 1바이트
    int b;     // 4바이트 정렬 필요
    double c;  // 8바이트 정렬 필요
};
alignof(Example) = 8  // 가장 큰 멤버(double)의 정렬
```

### alignas 지정자

변수나 타입의 정렬을 명시적으로 지정합니다.

```cpp
// 변수 정렬 지정
alignas(16) float simd_array[4];  // 16바이트 정렬

// 구조체 정렬 지정
struct alignas(64) CacheLine {
    char data[64];
};  // 64바이트 정렬 (캐시 라인 크기)

// 타입의 정렬을 다른 타입에 맞춤
struct alignas(alignof(T)) RawStorage {
    uint8_t data[sizeof(T)];
};
```

---

## 문제 상황

### BlockAllocator 원래 구현

```cpp
template<typename T, size_t block_size = 256>
struct BlockAllocator
{
    struct Block
    {
        // ⚠️ 문제: uint8_t 배열은 1바이트 정렬
        uint8_t mem[sizeof(T) * block_size];
    };
    std::vector<Block> blocks;
    std::vector<T*> free_list;

    template<typename... ARG>
    inline T* allocate(ARG&&... args)
    {
        // ...
        T* ptr = (T*)block.mem;  // ⚠️ 미정렬 가능!
        return new (ptr) T(...);  // placement new
    }
};
```

### 문제 시나리오

```
┌─────────────────────────────────────────────────────────────────┐
│              BlockAllocator<SomeStruct> 문제                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  struct SomeStruct {                                            │
│      double value;      // alignof(double) = 8                  │
│      std::atomic<int> count;  // alignof(atomic<int>) = 4      │
│  };                                                             │
│  alignof(SomeStruct) = 8  (가장 큰 멤버 기준)                   │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  Block.mem (uint8_t[]) 배열:                                    │
│  - alignof(uint8_t) = 1                                         │
│  - 주소가 1의 배수면 됨 (예: 0x1001)                            │
│                                                                 │
│  SomeStruct 할당 시:                                            │
│  - T* ptr = (T*)block.mem;                                      │
│  - 주소 0x1001에 SomeStruct 배치                                │
│  - 0x1001 % 8 != 0 → 미정렬!                                   │
│                                                                 │
│  결과:                                                          │
│  - double 접근 시 성능 저하                                     │
│  - atomic 연산 시 원자성 미보장 또는 크래시                     │
│  - SIMD 연산 시 크래시 가능                                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 해결: alignas(alignof(T)) 적용

### 수정된 코드

```cpp
template<typename T, size_t block_size = 256>
struct BlockAllocator
{
    struct Block
    {
        // ✅ T의 정렬 요구사항을 따르는 RawStruct
        struct alignas(alignof(T)) RawStruct
        {
            uint8_t data[sizeof(T)];
        };
        std::vector<RawStruct> mem;  // RawStruct의 벡터
    };
    std::vector<Block> blocks;
    std::vector<T*> free_list;

    template<typename... ARG>
    inline T* allocate(ARG&&... args)
    {
        // ...
        T* ptr = (T*)block.mem.data();  // ✅ 정렬 보장!
        return new (ptr) T(...);
    }
};
```

### 수정 핵심

```cpp
struct alignas(alignof(T)) RawStruct
{
    uint8_t data[sizeof(T)];
};
```

**동작 원리**:
1. `alignof(T)`: T 타입의 정렬 요구사항 (예: 8바이트)
2. `alignas(alignof(T))`: RawStruct를 T와 같은 정렬로 배치
3. `std::vector<RawStruct>`: 벡터가 RawStruct의 정렬을 보장
4. 결과: 각 `RawStruct`가 올바른 주소에 배치됨

### 메모리 레이아웃 비교

```
┌─────────────────────────────────────────────────────────────────┐
│                변경 전 vs 변경 후                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  T = SomeStruct (size=16, align=8) 가정                         │
│                                                                 │
│  변경 전 (uint8_t[]):                                           │
│  ┌─────────────────────────────────────────────┐                │
│  │  T[0]  │  T[1]  │  T[2]  │  T[3]  │ ...     │                │
│  └─────────────────────────────────────────────┘                │
│  주소: 0x1001 (미정렬 가능)                                     │
│         │                                                       │
│         └─ 8의 배수 아님!                                       │
│                                                                 │
│  변경 후 (alignas(8) RawStruct[]):                              │
│  ┌─────────────────────────────────────────────┐                │
│  │  T[0]  │  T[1]  │  T[2]  │  T[3]  │ ...     │                │
│  └─────────────────────────────────────────────┘                │
│  주소: 0x1000 (8의 배수 보장)                                   │
│         │                                                       │
│         └─ 항상 정렬됨!                                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 비유: 주차장

```
┌─────────────────────────────────────────────────────────────────┐
│                       주차장 비유                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  정렬 없는 주차장 (변경 전):                                     │
│  ┌───────────────────────────────────────────┐                  │
│  │ 🚗│🚗│🚗│  │🚗│  │🚗│🚗│  │🚗│            │                  │
│  └───────────────────────────────────────────┘                  │
│  차들이 아무데나 주차 → 큰 차가 두 자리에 걸침                   │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  정렬된 주차장 (변경 후):                                        │
│  ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐                      │
│  │🚗 │🚗 │🚗 │   │🚗 │🚗 │🚗 │🚗 │   │🚗 │                      │
│  └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘                      │
│  차 크기에 맞는 주차 라인 → 모든 차가 제자리에                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## VizMotive 적용 현황

### 이미 적용됨 ✅

VizMotive는 처음부터 올바른 구현을 사용하고 있었습니다.

**Allocator.h:26-32**:

```cpp
struct Block
{
    struct alignas(alignof(T)) RawStruct
    {
        uint8_t data[sizeof(T)];
    };
    std::vector<RawStruct> mem;
};
```

---

## 영향 받는 타입들

### DX12 Graphics 객체

BlockAllocator가 사용되는 곳:

```cpp
// CommandList 할당 (dx_2 #22 커밋 참조)
BlockAllocator<CommandList_DX12, 64> cmd_allocator;

// CommandList_DX12 구조체 내부:
// - atomic 변수들
// - 포인터들 (8바이트 정렬)
// - ComPtr들
```

정렬 문제가 있었다면:
- atomic 연산 실패
- 메모리 접근 성능 저하
- 일부 플랫폼에서 크래시

---

## 요약

| 항목 | 내용 |
|------|------|
| 문제 | BlockAllocator가 T 타입의 정렬 요구사항을 무시 |
| 원인 | `uint8_t[]` 배열은 1바이트 정렬만 보장 |
| 증상 | 성능 저하, atomic 실패, 일부 플랫폼 크래시 |
| 해결 | `alignas(alignof(T)) RawStruct` 래퍼 사용 |
| VizMotive | ✅ 이미 적용됨 |

### 핵심 교훈

> **Raw 메모리에 객체 배치 시 정렬 주의**
>
> `uint8_t[]`나 `char[]`에 placement new로 객체를 생성할 때는
> 반드시 `alignas(alignof(T))`로 정렬을 보장해야 함.
>
> 또는 `std::aligned_storage`, `alignas` 사용.
>
> 잘못된 정렬은 성능 문제부터 크래시까지 다양한 문제 유발.
