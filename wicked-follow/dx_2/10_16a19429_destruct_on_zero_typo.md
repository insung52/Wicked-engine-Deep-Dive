# 커밋 #10: 16a19429 - Fix typo in #1322

## 기본 정보

| 항목 | 내용 |
|------|------|
| 커밋 해시 | `16a19429` |
| 날짜 | 2025-11-23 |
| 작성자 | Turánszki János |
| 카테고리 | 버그수정 |
| 우선순위 | 높음 |

## 변경 파일 요약

| 파일 | 변경 |
|------|------|
| wiAllocator.h | `destruct_on_zero` 기본값 수정 |

**참고**: #1322는 커밋 #9 (`e1dc87e4`)의 Pull Request 번호입니다.

---

## 문제: 기본값 오류

### 커밋 #9에서의 실수

```cpp
// 커밋 #9에서 추가된 코드 (버그)
struct SharedBlockAllocator
{
    virtual uint32_t dec_refcount(void* ptr, bool destruct_on_zero = false) = 0;
    //                                                              ^^^^^
    //                                                              잘못됨!
};
```

### 왜 문제인가?

```
┌─────────────────────────────────────────────────────────────────┐
│              기본값 false의 문제점                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  dec_refcount()의 용도:                                         │
│  ─────────────────────                                          │
│  1. shared_ptr 소멸 시 호출 → 소멸자 호출 필요 (true)           │
│  2. shared_ptr 복사 해제 시 호출 → 소멸자 호출 필요 (true)      │
│  3. weak_ptr::lock() 롤백 시 → 소멸자 호출 불필요 (false)       │
│                                                                 │
│  대부분의 경우 (1, 2): 소멸자 호출 필요!                        │
│  특수한 경우 (3)만: 소멸자 호출 불필요                          │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  기본값 = false일 때의 문제:                                    │
│                                                                 │
│  // shared_ptr 소멸자                                           │
│  ~shared_ptr() {                                                │
│      if (ptr && allocator) {                                    │
│          allocator->dec_refcount(ptr);  // 기본값 false 사용    │
│      }                                                          │
│  }                                                              │
│                                                                 │
│  → refcount가 0이 되어도 소멸자 호출 안 됨!                     │
│  → 모든 Graphics 객체가 파괴되지 않음!                          │
│  → 메모리 누수, 리소스 누수                                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 해결: 기본값을 true로 수정

### 수정된 코드

```cpp
// 커밋 #10에서 수정
struct SharedBlockAllocator
{
    virtual uint32_t dec_refcount(void* ptr, bool destruct_on_zero = true) = 0;
    //                                                              ^^^^
    //                                                              올바름!
};
```

### 호출 패턴

```cpp
// 일반적인 경우 - 기본값 true 사용
allocator->dec_refcount(ptr);  // destruct_on_zero = true (기본값)
// → refcount 0이 되면 소멸자 호출 ✓

// weak_ptr::lock() 롤백 - 명시적으로 false 전달
allocator->dec_refcount(ptr, false);  // destruct_on_zero = false (명시적)
// → refcount 0이 되어도 소멸자 호출 안 함 ✓
```

---

## 비유: 쓰레기통 비우기

```
┌─────────────────────────────────────────────────────────────────┐
│                    쓰레기통 비유                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  상황: 사무실 쓰레기통 (= 객체)                                 │
│                                                                 │
│  dec_refcount = "쓰레기통에서 쓰레기 하나 제거"                 │
│  destruct_on_zero = "쓰레기통이 비면 씻을까요?"                 │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  기본값 = false (버그):                                         │
│  ─────────────────────                                          │
│  "쓰레기통이 비어도 기본적으로 안 씻어요"                       │
│  → 대부분의 경우 씻어야 하는데 안 씻음                          │
│  → 쓰레기통이 더러워짐 (메모리 누수)                            │
│                                                                 │
│  기본값 = true (올바름):                                        │
│  ─────────────────────                                          │
│  "쓰레기통이 비면 기본적으로 씻어요"                            │
│  → 특별한 경우에만 "이번엔 안 씻어도 돼요" 지시                 │
│  → 쓰레기통이 깨끗함 (정상 동작)                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 타임라인: 커밋 #9 → #10 → #19

```
┌─────────────────────────────────────────────────────────────────┐
│              destruct_on_zero 파라미터의 생애주기                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  커밋 #9 (2025-11-23):                                          │
│  ─────────────────────                                          │
│  + destruct_on_zero 파라미터 추가                               │
│  × 기본값 실수로 false로 설정                                   │
│                                                                 │
│          │                                                      │
│          ▼                                                      │
│                                                                 │
│  커밋 #10 (2025-11-23, 같은 날):                                │
│  ──────────────────────────────                                 │
│  ✓ 기본값을 true로 수정                                         │
│                                                                 │
│          │                                                      │
│          ▼                                                      │
│                                                                 │
│  커밋 #19 (2025-12-14):                                         │
│  ─────────────────────                                          │
│  - destruct_on_zero 파라미터 완전 제거                          │
│  + try_inc_refcount() 도입으로 롤백 자체가 불필요해짐           │
│                                                                 │
│  최종 상태: dec_refcount(void* ptr) - 파라미터 없음             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 교훈: 기본값 설계

### 좋은 기본값의 원칙

```
┌─────────────────────────────────────────────────────────────────┐
│              기본값 설계 원칙                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 가장 일반적인 사용 사례를 기본값으로                        │
│     ─────────────────────────────────────                       │
│     dec_refcount() 호출의 99%는 소멸자 호출 필요                │
│     → 기본값 = true                                             │
│                                                                 │
│  2. 안전한 쪽을 기본값으로                                      │
│     ─────────────────────────────                               │
│     true (파괴함) vs false (파괴 안 함)                         │
│     → false가 기본이면 메모리 누수                              │
│     → true가 기본이면 최악의 경우 이중 파괴 (더 빨리 발견됨)   │
│                                                                 │
│  3. "특별한 경우"에 명시적으로 지정하게                         │
│     ─────────────────────────────────────                       │
│     특별한 동작을 원할 때만 파라미터 명시                       │
│     일반적인 경우는 기본값으로 자연스럽게 동작                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 이 버그가 발생한 이유 추측

```cpp
// 커밋 #9 작성 시 생각의 흐름 (추측):

// "weak_ptr::lock()에서 소멸자 호출을 막아야 해"
// "destruct_on_zero = false로 호출해야지"
allocator->dec_refcount(ptr, false);

// "아, 근데 인터페이스에 파라미터가 없네. 추가해야겠다"
virtual uint32_t dec_refcount(void* ptr, bool destruct_on_zero = false) = 0;
//                                                              ^^^^^
//                                        방금 쓴 false를 그대로 기본값으로...

// 실수: 특수한 경우(false)를 기본값으로 설정해버림
```

---

## VizMotive 적용 현황

### 적용 완료 ✅

**적용 일자**: 2026-01-28

커밋 #9와 함께 올바른 기본값 `true`로 적용됨.

### 참고

VizMotive에서는 커밋 #9와 #10을 함께 적용했으므로, 이 버그를 경험하지 않았습니다.

또한 커밋 #19 적용 이후에는 `destruct_on_zero` 파라미터 자체가 제거되어 더 이상 관련 없습니다.

---

## 요약

| 항목 | 내용 |
|------|------|
| 문제 | 커밋 #9에서 `destruct_on_zero` 기본값을 실수로 `false`로 설정 |
| 증상 | 모든 객체의 소멸자가 호출되지 않음 → 메모리/리소스 누수 |
| 해결 | 기본값을 `true`로 수정 |
| 참고 | 커밋 #19에서 이 파라미터 자체가 제거됨 |
| VizMotive | ✅ 적용 완료 (커밋 #9와 함께) |

### 핵심 교훈

> **기본값은 "가장 일반적인 사용 사례"로 설정**
>
> 특수한 경우를 위해 파라미터를 추가할 때,
> 그 특수한 값을 기본값으로 설정하지 않도록 주의.
>
> 대부분의 호출에서 원하는 동작이 기본값이 되어야 함.
