# 커밋 #17: 6c973af6 - Block Compressed Texture Saving Fix

## 기본 정보

| 항목 | 내용 |
|------|------|
| 커밋 해시 | `6c973af6` |
| 날짜 | 2025-06-28 |
| 작성자 | Turánszki János |
| 카테고리 | 버그수정 |
| 우선순위 | 중간 |

## 변경 파일 요약

| 파일 | 변경 |
|------|------|
| wiGraphics.h | `ComputeTextureMemorySizeInBytes()` 함수 수정 |

---

## 배경 지식: Block Compressed (BC) 텍스처

### BC 포맷이란?

**Block Compression**은 GPU 텍스처 압축 방식으로, 텍스처를 4x4 픽셀 블록 단위로 압축합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    Block Compression 개념                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  원본 텍스처 (RGBA 32비트)        BC 압축 후                     │
│  ┌────────────────────┐          ┌────────────────────┐         │
│  │████████████████████│          │ Block │ Block │    │         │
│  │████████████████████│    →     │ 0     │ 1     │... │         │
│  │████████████████████│          ├───────┼───────┤    │         │
│  │████████████████████│          │ Block │ Block │    │         │
│  └────────────────────┘          │ N     │ N+1   │... │         │
│                                  └───────┴───────┴────┘         │
│  각 픽셀 = 4 bytes               각 블록 = 8 or 16 bytes        │
│  총: width × height × 4 bytes    (4×4 픽셀을 한 블록으로)        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### BC 포맷 종류

| 포맷 | 블록 크기 | 블록당 바이트 | 용도 |
|------|-----------|---------------|------|
| BC1 | 4×4 | 8 bytes | RGB (1비트 알파) |
| BC2 | 4×4 | 16 bytes | RGBA (명시적 알파) |
| BC3 | 4×4 | 16 bytes | RGBA (보간 알파) |
| BC4 | 4×4 | 8 bytes | 단일 채널 (R) |
| BC5 | 4×4 | 16 bytes | 2채널 (RG, 노멀맵) |
| BC6H | 4×4 | 16 bytes | HDR RGB |
| BC7 | 4×4 | 16 bytes | 고품질 RGBA |

### 압축률 비교

```
100×100 텍스처 예시:

RGBA32 (비압축):  100 × 100 × 4 = 40,000 bytes
BC1:              25 × 25 × 8   = 5,000 bytes   (8:1 압축)
BC3/BC7:          25 × 25 × 16  = 10,000 bytes  (4:1 압축)
```

---

## 배경 지식: 블록 수 계산

### 핵심 공식

BC 텍스처의 블록 수는 **ceiling division**으로 계산해야 합니다:

```cpp
// 올바른 계산 (ceiling division)
num_blocks_x = (width + block_size - 1) / block_size;
num_blocks_y = (height + block_size - 1) / block_size;

// 또는 C++에서
num_blocks_x = (width + 3) / 4;  // block_size = 4
```

### 왜 Ceiling Division인가?

```
┌─────────────────────────────────────────────────────────────────┐
│              100 픽셀을 4픽셀 블록으로 나누기                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  픽셀:  [0-3][4-7][8-11]...[92-95][96-99]                       │
│  블록:    0    1    2   ...  23     24                          │
│                                  ↑                              │
│                           마지막 블록은 4픽셀이 아님!            │
│                           (96,97,98,99 = 4픽셀이지만             │
│                            100/4 = 25로 정확히 나눠짐)           │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  문제 예시: 100 픽셀                                            │
│                                                                 │
│  잘못된 계산: 100 / 4 = 25 블록 (정확히 나눠지는 경우 OK)        │
│  올바른 계산: (100 + 3) / 4 = 25 블록                           │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  문제 예시: 99 픽셀                                             │
│                                                                 │
│  잘못된 계산: 99 / 4 = 24 블록 ❌ (마지막 3픽셀 누락!)          │
│  올바른 계산: (99 + 3) / 4 = 25 블록 ✓                          │
│                                                                 │
│  픽셀:  [0-3][4-7]...[92-95][96-98]                             │
│  블록:    0    1  ...  23     24                                │
│                              ↑                                  │
│                        마지막 블록은 3픽셀만 사용                │
│                        (패딩으로 4×4 블록 채움)                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 문제 상황

### 잘못된 Mip 레벨 블록 계산

**기존 코드의 문제**:

```cpp
// 잘못된 방식: mip 0에서 블록 수 계산 후 shift
const uint32_t num_blocks_x = desc.width / pixels_per_block;
const uint32_t num_blocks_y = desc.height / pixels_per_block;

for (uint32_t mip = 0; mip < mips; ++mip)
{
    uint32_t mip_blocks_x = num_blocks_x >> mip;  // 잘못된 shift!
    uint32_t mip_blocks_y = num_blocks_y >> mip;
    // ...
}
```

### 왜 잘못되었는가?

```
┌─────────────────────────────────────────────────────────────────┐
│            100×100 BC 텍스처의 Mip 레벨별 블록 수                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  잘못된 방식 (블록 수 shift):                                    │
│  ──────────────────────────                                     │
│  Mip 0: blocks = 100/4 = 25                                     │
│  Mip 1: blocks = 25 >> 1 = 12  ← 12×4 = 48픽셀만 커버           │
│  Mip 2: blocks = 12 >> 1 = 6   ← 6×4 = 24픽셀만 커버            │
│                                                                 │
│  실제 필요:                                                      │
│  ──────────                                                     │
│  Mip 0: 100×100 픽셀 → 25×25 블록                               │
│  Mip 1: 50×50 픽셀   → 13×13 블록 (50/4=12.5 → ceil=13)         │
│  Mip 2: 25×25 픽셀   → 7×7 블록 (25/4=6.25 → ceil=7)            │
│                                                                 │
│  차이:                                                          │
│  ──────                                                         │
│  Mip 1: 12 vs 13 → 1블록 부족!                                  │
│  Mip 2: 6 vs 7   → 1블록 부족!                                  │
│                                                                 │
│  결과: 텍스처 저장 시 데이터 일부 누락                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 시각적 문제

```
┌─────────────────────────────────────────────────────────────────┐
│                   Mip 1 (50×50 픽셀) 비교                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  잘못된 계산 (12×12 블록 = 48×48 픽셀)                          │
│  ┌────────────────────────────────────────────┐                 │
│  │████████████████████████████████████████████│← 48픽셀         │
│  │████████████████████████████████████████████│                 │
│  │████████████████████████████████████████████│                 │
│  │████████████████████████████████████████████│                 │
│  │████████████████████████████████████████████│← 48픽셀         │
│  └────────────────────────────────────────────┘                 │
│                                        ↑ 오른쪽/아래 2픽셀 누락! │
│                                                                 │
│  올바른 계산 (13×13 블록 = 52×52 픽셀 커버리지)                  │
│  ┌──────────────────────────────────────────────┐               │
│  │██████████████████████████████████████████████│← 52픽셀       │
│  │██████████████████████████████████████████████│  (패딩 포함)  │
│  │██████████████████████████████████████████████│               │
│  │██████████████████████████████████████████████│               │
│  │██████████████████████████████████████████████│← 52픽셀       │
│  └──────────────────────────────────────────────┘               │
│    ↑ 50×50 실제 픽셀 + 패딩으로 52×52 커버                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 해결: 올바른 Mip 레벨별 블록 계산

### 수정된 코드

```cpp
// 올바른 방식: 각 mip 레벨에서 픽셀 크기 계산 후 블록 수 계산
for (uint32_t mip = 0; mip < mips; ++mip)
{
    // 1. 먼저 mip 레벨의 픽셀 크기 계산
    const uint32_t mip_width = std::max(1u, desc.width >> mip);
    const uint32_t mip_height = std::max(1u, desc.height >> mip);
    const uint32_t mip_depth = std::max(1u, desc.depth >> mip);

    // 2. 그 다음 ceiling division으로 블록 수 계산
    const uint32_t num_blocks_x = (mip_width + pixels_per_block - 1) / pixels_per_block;
    const uint32_t num_blocks_y = (mip_height + pixels_per_block - 1) / pixels_per_block;

    // 3. 메모리 크기 누적
    size += num_blocks_x * num_blocks_y * mip_depth * bytes_per_block;
}
```

### 핵심 차이

| 단계 | 잘못된 방식 | 올바른 방식 |
|------|-------------|-------------|
| 1 | 블록 수 계산 (mip 0) | 픽셀 크기 계산 (각 mip) |
| 2 | 블록 수 shift (각 mip) | 블록 수 계산 (ceiling div) |
| 문제 | 나머지 픽셀 누락 | 모든 픽셀 커버 |

### 수치 비교: 100×100 BC1 텍스처

| Mip | 픽셀 크기 | 잘못된 블록 수 | 올바른 블록 수 | 차이 |
|-----|-----------|----------------|----------------|------|
| 0 | 100×100 | 25×25 = 625 | 25×25 = 625 | 0 |
| 1 | 50×50 | 12×12 = 144 | 13×13 = 169 | **+25** |
| 2 | 25×25 | 6×6 = 36 | 7×7 = 49 | **+13** |
| 3 | 12×12 | 3×3 = 9 | 3×3 = 9 | 0 |
| 4 | 6×6 | 1×1 = 1 | 2×2 = 4 | **+3** |
| 5 | 3×3 | 0×0 = 0 | 1×1 = 1 | **+1** |
| 6 | 1×1 | 0×0 = 0 | 1×1 = 1 | **+1** |

**총 차이**: 815 블록 vs 858 블록 = **43블록 × 8bytes = 344 bytes 누락!**

---

## VizMotive 적용 현황

### 적용 완료 ✅

**적용 일자**: 2026-01-27

### 적용 위치

**GBackend.h:1956-1976**:

```cpp
constexpr size_t ComputeTextureMemorySizeInBytes(const TextureDesc& desc)
{
    size_t size = 0;
    const uint32_t bytes_per_block = GetFormatStride(desc.format);
    const uint32_t pixels_per_block = GetFormatBlockSize(desc.format);
    const uint32_t mips = GetMipCount(desc);
    for (uint32_t layer = 0; layer < desc.array_size; ++layer)
    {
        for (uint32_t mip = 0; mip < mips; ++mip)
        {
            // 올바른 방식: 각 mip 레벨에서 픽셀 크기 먼저 계산
            const uint32_t mip_width = std::max(1u, desc.width >> mip);
            const uint32_t mip_height = std::max(1u, desc.height >> mip);
            const uint32_t mip_depth = std::max(1u, desc.depth >> mip);

            // ceiling division으로 블록 수 계산
            const uint32_t num_blocks_x = (mip_width + pixels_per_block - 1) / pixels_per_block;
            const uint32_t num_blocks_y = (mip_height + pixels_per_block - 1) / pixels_per_block;

            size += num_blocks_x * num_blocks_y * mip_depth * bytes_per_block;
        }
    }
    size *= desc.sample_count;
    return size;
}
```

---

## 영향 범위

### 이 함수가 사용되는 곳

- 텍스처 메모리 사용량 계산
- GPU 메모리 통계
- 텍스처 저장 시 버퍼 크기 결정
- 디버그/프로파일링 정보

### 버그 증상 (수정 전)

- BC 텍스처 저장 시 mip 레벨 일부 데이터 누락
- 텍스처 로드 후 하위 mip에서 아티팩트
- LOD 전환 시 깨진 텍스처

---

## 요약

| 항목 | 내용 |
|------|------|
| 문제 | BC 텍스처 mip 레벨 블록 수 계산 오류 |
| 원인 | mip 0 블록 수를 shift하는 방식 (나머지 픽셀 누락) |
| 해결 | 각 mip에서 픽셀 크기 계산 → ceiling division으로 블록 수 계산 |
| 핵심 공식 | `num_blocks = (mip_pixels + block_size - 1) / block_size` |
| VizMotive | ✅ 적용 완료 (2026-01-27) |

### 핵심 교훈

> **BC 텍스처에서 블록 수 ≠ 픽셀 수 / 4**
>
> 반드시 ceiling division을 사용해야 함:
> `(pixels + 3) / 4`
>
> 그리고 mip 레벨은 **픽셀 크기를 먼저 계산**한 후 블록 수를 계산해야 함.
> 블록 수를 shift하면 안 됨!
